using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CoFi
{
    class Program
    {
        static void Main(string[] args)
        {
            //reverseParentheses("The ((quick (brown) (fox) jumps over the lazy) dog)");
            //var a = new int[] { 2, 1, 2, 1, 1, 1, 2 };
            //var b = new int[] { 1, 1, 2, 1, 2, 1, 2 };
            //areSimilar(a, b);
            //var b = new int[] { 2, 4, 3, 5, 1 };
            //firstDuplicate(b);
            //firstNotRepeatingCharacter("abacabad");
            /*var grid = new char[9][];
            grid[0] = new char[] { '.', '.', '.', '1', '4', '.', '.', '2', '.' };
            grid[1] = new char[] { '.', '.', '6', '.', '.', '.', '.', '.', '.' };
            grid[2] = new char[] { '.', '.', '.', '.', '.', '.', '.', '.', '.' };
            grid[3] = new char[] { '.', '.', '1', '.', '.', '.', '.', '.', '.'};
            grid[4] = new char[] { '.', '6', '7', '.', '.', '.', '.', '.', '9' };
            grid[5] = new char[] { '.', '.', '.', '.', '.', '.', '8', '1', '.' };
            grid[6] = new char[] { '.', '3', '.', '.', '.', '.', '.', '.', '6' };
            grid[7] = new char[] { '.', '.', '.', '.', '.', '7', '.', '.', '.' };
            grid[8] = new char[] { '.', '.', '.', '5', '.', '.', '.', '7', '.' };*/
            //sudoku2(grid);
            //palindromeRearranging("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaabc");
            //almost_palindromes("abcdcaa");
            //var arr = new int[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };
            //doSearch(arr, 73);

            //var crypt = new string[] { "A","A","A" };
            //var solution = new char[1][];
            //solution[0] = new char[] { 'A', '0' };
            /*solution[1] = new char[] { 'M', '1' };
            solution[2] = new char[] { 'Y', '2' };
            solution[3] = new char[] { 'E', '5' };
            solution[4] = new char[] { 'N', '6' };
            solution[5] = new char[] { 'D', '7' };
            solution[6] = new char[] { 'R', '8' };
            solution[7] = new char[] { 'S', '9' };*/
            //isCryptSolution(crypt, solution);

            /*var t = new ListNode<int>();
            t.value = 3;
            t.next = new ListNode<int>();
            t.next.value = 1;
            t.next.next = new ListNode<int>();
            t.next.next.value = 2;
            t.next.next.next = new ListNode<int>();
            t.next.next.next.value = 3;
            t.next.next.next.next = new ListNode<int>();
            t.next.next.next.next.value = 4;
            t.next.next.next.next.next = new ListNode<int>();
            t.next.next.next.next.next.value = 5;
            removeKFromList(t, 3);*/

            RevereseNumberInPlace(1534236469);

            /*var t = new ListNode<int>();
            t.value = 9876;
            t.next = new ListNode<int>();
            t.next.value = 5432;
            t.next.next = new ListNode<int>();
            t.next.next.value = 1999;

            var t2 = new ListNode<int>();
            t2.value = 1;
            t2.next = new ListNode<int>();
            t2.next.value = 8001;*/
            //addTwoHugeNumbers(t, t2);

            /*var t = new ListNode<int>();
            t.value = 1;
            t.next = new ListNode<int>();
            t.next.value = 1;
            t.next.next = new ListNode<int>();
            t.next.next.value = 2;
            t.next.next.next = new ListNode<int>();
            t.next.next.next.value = 4;

            var t2 = new ListNode<int>();
            t2.value = 0;
            t2.next = new ListNode<int>();
            t2.next.value = 3;
            t2.next.next = new ListNode<int>();
            t2.next.next.value = 5;
            mergeTwoLinkedLists(t, t2);*/

            /*var t = new ListNode<int>();
            t.value = 1;
            t.next = new ListNode<int>();
            t.next.value = 2;
            t.next.next = new ListNode<int>();
            t.next.next.value = 3;
            t.next.next.next = new ListNode<int>();
            t.next.next.next.value = 4;
            t.next.next.next.next = new ListNode<int>();
            t.next.next.next.next.value = 5;*/
            //reverseNodesInKGroups(t, 2);

            //rearrangeLastN(t, 3);

            //areEquallyStrong(10, 15,10,16);

            //var a = new int[] { 2,4,1,0 };
            //arrayMaximalAdjacentDifference(a);

            //isIPv4Address("172.316.254.1");

            /*int tsmCount = 3;
            string[] availableLocations = new string[] { "SF", "NY", "Seattle" };
            int minExperience = 3;
            string[] jobApplications = new string[] { "JohnSmith 4 NY",
                   "John 2 NY",
                   "Frank 4 SF",
                   "Katy 3 SF",
                   "Michael 3 Washington",
                   "Tom 10 SF" };
            assignJobApplications(tsmCount, availableLocations, minExperience, jobApplications);*/

            //var input = new int[] { 5, 3, 6, 9, 10 };
            //AvoidObstacles(input);
            //TreeNode tree = new TreeNode(10);

            /*tree.left = new TreeNode(5);
            tree.right = new TreeNode(-3);
            tree.left.left = new TreeNode(3);
            tree.left.right = new TreeNode(2);
            tree.right.right = new TreeNode(11);
            tree.left.left.left = new TreeNode(3);
            tree.left.left.right = new TreeNode(-2);
            tree.left.right.right = new TreeNode(1);
            PathSum(tree, 8);*/

            //BinaryGap(22);

            //FindAnagrams("aaaaaaaaaa", "aaaaaaaaaaaaa"); 
            //BulbSwitch(3);

            //var input = new int[] { 10, 15, 3, 7 };
            //IsSumPossible(input, 17);

            //int[] numbers = new int[] { 0,4,3,0 };
            //FindProduct(numbers);
            //IsSumPossibleRetIndices(numbers, 0);

            /*var t = new ListNode (2);
            t.next = new ListNode (4);
            t.next.next = new ListNode (3);
            //t.next.next.next = new ListNode<int>();
            //t.next.next.next.value = 4;

            var t2 = new ListNode (5);
            t2.next = new ListNode (6);
            t2.next.next = new ListNode (4);

            AddTwoNumbers(t, t2);*/

            //LengthOfLongestSubstring("abcabcbb");

            LongestPalindrome("babad");

        }

        static string reverseString(string s)
        {
            char[] try1 = s.ToCharArray();
            string r = "";
            for (int i = try1.Length - 1; i >= 0; i--)
                r += try1[i].ToString();

            return r;
        }

        static string reverseParentheses(string s)
        {
            int begin = 0;
            int end = s.Length - 1;
            for (int i = 0; i < s.Length; i++)
            {
                Console.WriteLine(s[i]);
                if (s[i].Equals('('))
                    begin = i;
                if (s[i].Equals(')'))
                {
                    end = i;
                    string temp = s.Substring(begin + 1, end - begin - 1);
                    return reverseParentheses(s.Substring(0, begin) + temp.Reverse() + s.Substring(end + 1));
                }
            }
            return s;
        }
        static bool areSimilar(int[] a, int[] b)
        {
            var foundDiff = 0;
            if (a.Length != b.Length)
                return false;
            for (var i = 0; i < a.Length; i++)
            {
                if (Array.IndexOf(b, a[i]) == -1)
                    return false;
                if (foundDiff > 1)
                    return false;
                if (a[i] == b[i])
                    continue;
                for (var j = 0; j < b.Length; j++)
                {
                    if (foundDiff >= 1)
                        return false;
                    if (a[i] == b[j] && a[j] != b[j])
                    {
                        foundDiff++;
                        var temp = b[i];
                        b[i] = b[j];
                        b[j] = temp;
                        break;
                    }
                }
            }
            Console.WriteLine(foundDiff > 1 ? false : true);
            return foundDiff > 1 ? false : true;
        }

        static int firstDuplicate(int[] a)
        {
            for (var i = 0; i < a.Length; i++)
            {
                var position = Math.Abs(a[i]) - 1;
                if (a[position] < 0) return Math.Abs(a[i]);
                a[position] = -a[position];
            }
            return -1;
        }

        static char firstNotRepeatingCharacter(string s)
        {
            var t = s.GroupBy(e => e).Where(e => e.Count() == 1).Select(e => e.Key).FirstOrDefault();
            return !char.IsLetter(t) ? '_' : t;
        }

        static bool palindromeRearranging(string inputString)
        {
            //var countList = new List<int>();
            var t = inputString.GroupBy(e => e).Where(e => e.Count() % 2 == 1).Count() <= 1;
            return t;
        }

        static int almost_palindromes(string str)
        {
            var count = 0;
            var j = str.Length - 1;
            for (var i = 0; i < str.Length; i++)
            {
                if (i == j)
                    break;
                if (str[i] != str[j])
                    count += 2;
                j--;
            }
            return count;
        }

        public static int doSearch(int[] array, int targetValue)
        {
            int min = 0;
            //System.out.println(Arrays.toString(array));
            int max = array.Length - 1;
            int guess;

            while (max >= min)
            {
                //int avg = (min + max) / 2;
                guess = (min + max) / 2;
                if (array[guess] == targetValue)
                    return guess;
                if (targetValue > array[guess])
                    min = guess + 1;
                else
                    max = guess - 1;
            }
            return -1;
        }
        public static bool isCryptSolution(string[] crypt, char[][] solution)
        {
            var sumStr = new List<string>();
            var set = new Dictionary<char, char>();
            for (var i = 0; i < solution.Length; i++)
            {
                set[solution[i][0]] = solution[i][1];
            }



            foreach (var str in crypt)
            {
                if (str.Length != 1 && set[str[0]] == '0') return false;
                var strBuilder = new StringBuilder();
                for (var k = 0; k < str.Length; k++)
                {
                    strBuilder.Append(set[str[k]]);
                }
                sumStr.Add(strBuilder.ToString());
            }
            return Convert.ToInt64(sumStr.ElementAt(0)) + Convert.ToInt64(sumStr.ElementAt(1)) == Convert.ToInt64(sumStr.ElementAt(2));
        }



        public static ListNode<int> removeKFromList(ListNode<int> l, int k)
        {
            ListNode<int> x = l;
            ListNode<int> prev = null;
            while (x != null)
            {
                ListNode<int> x_next = x.next;
                if (x.value == k)
                {
                    if (prev != null)
                    {
                        prev.next = x_next;
                    }
                    else
                    {
                        l = x_next;
                    }
                }
                else
                {
                    prev = x;
                }
                x = x_next;
            }

            return l;
        }

        public static int RevereseNumberInPlace(int number)
        {
            long rev = 0L;

            while (number != 0)
            {
                rev = (rev * 10) + (number % 10);
                number = number / 10;

            }
            if ((rev > int.MaxValue) || (rev < int.MinValue))
                return 0;
            return Convert.ToInt32(rev);
        }

        static ListNode<int> addTwoHugeNumbers(ListNode<int> a, ListNode<int> b)
        {
            int countA = 0, countB = 0;
            //reverse list a 
            var curr = a;
            ListNode<int> prev = null;
            while (curr != null)
            {
                countA++;
                var temp = curr.next;
                curr.next = prev;
                prev = curr;
                curr = temp;
            }
            //prev is now new root!
            a = prev; //now it is reversed

            //reverse list b
            curr = b;
            prev = null;
            while (curr != null)
            {
                countB++;
                var temp = curr.next;
                curr.next = prev;
                prev = curr;
                curr = temp;
            }
            b = prev; //now it is reversed


            var stepA = a;
            var stepB = b;

            ListNode<int> result = (countA >= countB) ? a : b;
            curr = result;


            int carryOver = 0;


            while (result != null)
            {
                int aValue = (stepA == null) ? 0 : stepA.value;
                int bValue = (stepB == null) ? 0 : stepB.value;

                int tot = aValue + bValue + carryOver;

                if (tot / 10000 > 0)
                {
                    carryOver = 1;
                    tot = tot % 10000;
                }
                else
                {
                    carryOver = 0;
                }
                if (stepA != null) stepA = stepA.next;
                if (stepB != null) stepB = stepB.next;

                result.value = tot;
                if (result.next == null && carryOver == 1)
                {
                    var n = new ListNode<int>();
                    n.value = 1;
                    result.next = n;
                    result = result.next.next;

                }
                else
                    result = result.next;

            }
            prev = null;
            while (curr != null)
            {
                var temp = curr.next;
                curr.next = prev;
                prev = curr;
                curr = temp;
            }
            result = prev; //now it is reversed

            return result;

        }

        static ListNode<int> mergeTwoLinkedLists(ListNode<int> l1, ListNode<int> l2)
        {
            if (l1 == null) return l2;
            if (l2 == null) return l1;
            if (l1.value < l2.value)
            {
                l1.next = mergeTwoLinkedLists(l1.next, l2);
                return l1;
            }

            else
            {
                l2.next = mergeTwoLinkedLists(l1, l2.next);
                return l2;
            }
        }

        static ListNode<int> reverseNodesInKGroups(ListNode<int> l, int k)
        {
            if (k == 1)
                return l;
            int len = 0;
            ListNode<int> curr = l;
            ListNode<int> prev = null;
            ListNode<int> retList = null;
            ListNode<int> t = null;

            while (curr != null)
            {
                len++;
                curr = curr.next;
            }
            curr = l;

            if (len > k)
            {
                while (len >= 0 && len >= k)
                {
                    var swaps = k;
                    prev = null;
                    while (swaps > 0)
                    {
                        var temp = curr.next;
                        curr.next = prev;
                        prev = curr;
                        curr = temp;
                        swaps--;
                    }
                    if (retList == null)
                        retList = prev;
                    else
                    {
                        t = retList;
                        while (t.next != null)
                        {
                            t = t.next;
                        }
                        t.next = prev;
                    }
                    len = len - k;
                }
            }
            else
            {
                prev = null;
                while (k >= 0)
                {
                    var temp = curr.next;
                    curr.next = prev;
                    prev = curr;
                    curr = temp;
                    k--;
                }
                retList = prev;
            }
            if (len > 0 && curr != null)
            {
                t = retList;
                while (t.next != null)
                {
                    t = t.next;
                }
                t.next = curr;
            }
            return retList;
        }

        static ListNode<int> rearrangeLastN(ListNode<int> l, int n)
        {
            var current = l;
            if (n == 0) return l;
            for (int i = 0; i < n; i++)
            {
                if (current == null) return l;
                current = current.next;
            }
            if (current == null) return l;
            var head = l;
            while (current.next != null)
            {
                current = current.next;
                head = head.next;
            }
            var result = head.next;
            head.next = null;
            current.next = l;
            return result;

        }

        static bool areEquallyStrong(int yourLeft, int yourRight, int friendsLeft, int friendsRight)
        {
            return (yourRight == friendsRight && yourLeft == friendsLeft) || (yourRight == friendsLeft && yourLeft == friendsRight);
        }

        static int arrayMaximalAdjacentDifference(int[] inputArray)
        {
            var maxDif = int.MinValue;
            for (var i = 0; i < inputArray.Length - 1; i++)
            {
                maxDif = Math.Max(maxDif, Math.Abs(inputArray[i] - inputArray[i + 1]));
            }
            return maxDif;
        }

        static bool isIPv4Address(string inputString)
        {
            var num = 0;
            var ipArr = inputString.Split('.');
            if (ipArr.Length != 4) return false;
            foreach (var ele in ipArr)
            {
                if (!int.TryParse(ele, out num))
                    return false;
                if (num < 0 || num > 255)
                    return false;
            }
            return true;
        }

        static int[] assignJobApplications(int tsmCount, string[] availableLocations, int minExperience, string[] jobApplications)
        {
            List<int> retList = new List<int>();
            int count = 0;
            var appArr = new List<string>();
            foreach (var app in jobApplications)
            {
                if (appArr.Count > 0) appArr.RemoveRange(0, 3);
                appArr.AddRange(app.Split(' ').ToList());
                if (Convert.ToInt32(appArr[1]) < minExperience || !availableLocations.Contains(appArr[2]))
                    retList.Add(-1);
                else
                {
                    if (count == tsmCount)
                        count = 0;
                    count++;
                    retList.Add(count);
                }

            }

            return retList.ToArray();
        }

        static int AvoidObstacles(int[] inputArray)
        {
            int count = 2;
            var ableToJump = false;
            while (!ableToJump)
            {
                foreach (int val in inputArray)
                {
                    if (val == count || val % count == 0)
                    {
                        count++;
                        ableToJump = false;
                        break;
                    }
                    else
                    {
                        ableToJump = true;
                    }
                }
            }
            return count;
        }

        public static int PathSum(TreeNode root, int sum)
        {
            return FindPathSum(root, sum);

        }

        public static int FindPathSum(TreeNode root, int sum)
        {
            if (root == null) return 0;
            int count = 0;
            Console.WriteLine(root.val);
            if (sum == root.val && root.left == null && root.right == null)
            {
                count++;
            }

            else if (sum != root.val && root.left == null && root.right == null)
                return 0;
            else
            {
                FindPathSum(root.left, sum - root.val);
                FindPathSum(root.right, sum - root.val);
            }
            return count;
        }

        public static int BinaryGap(int N)
        {
            int maxDistance = 0;
            bool foundOne = false;
            int distance = 0;
            string binaryCode = Convert.ToString(N, 2);
            foreach(char c in binaryCode)
            {
                if (c == '1' && !foundOne)  foundOne = true;
                else if(foundOne && c == '1')
                {
                    distance++;
                    maxDistance = Math.Max(maxDistance, distance);
                    distance = 0;
                }
                else distance++;
            }
            return maxDistance;
        }

        private static bool compare(int[] arr1, int[] arr2)
        {
            int MAX = 256;
            for (int i = 0; i < MAX; i++)
                if (arr1[i] != arr2[i])
                    return false;
            return true;
        }

        // This function search for all permutations
        // of pat[] in txt[]
        public static IList<int> FindAnagrams_Like(string s, string p)
        {
            int MAX = 256;
            int M = p.Length < s.Length ? p.Length : s.Length;
            int N = p.Length < s.Length ? s.Length : p.Length;
            var outList = new List<int>();

            if (M == 0 || N == 0)
                return outList;


            // countP[]:  Store count of all 
            // characters of pattern
            // countTW[]: Store count of current
            // window of text
            int[] countP = new int[MAX];
            int[] countTW = new int[MAX];
            for (int i = 0; i < M; i++)
            {
                (countP[p[i]])++;
                (countTW[s[i]])++;
            }

            // Traverse through remaining characters
            // of pattern
            for (int i = M; i < N; i++)
            {
                // Compare counts of current window
                // of text with counts of pattern[]
                if (compare(countP, countTW))
                    outList.Add(i - M);
                    //System.out.println("Found at Index " + (i - M));

                // Add current character to current 
                // window
                countTW[s[i]]++;

                // Remove the first character of previous
                // window
                countTW[s[i-M]]--;
            }

            // Check for the last window in text
            if (compare(countP, countTW))
                outList.Add(N - M);
            //System.out.println("Found at Index " + (N - M));
            return outList;
        }

        public static IList<int> FindAnagrams_DontLike(string s, string p)
        {
            int[] hash = new int[128];
            for (int i = 0; i < p.Length; i++)
            {
                hash[p[i]]++;
            }
            List<int> res = new List<int>();
            int start = 0;
            //The goal is to make sure the whole hash array is >= 0.
            //When hash[i] < 0, move start to get back to 0.
            for (int i = 0; i < s.Length; i++)
            {
                char c = s[i];
                hash[c]--;
                while (hash[c] < 0)
                {
                    hash[s[start]]++;
                    start++;
                }
                if (i - start + 1 == p.Length)
                {
                    res.Add(start);
                }
            }
            return res;
        }

        public static int BulbSwitch(int n)
        {
            int count = 0;
            int i = 1;
            while(i * i <= n){
                count++;
                i++;
            }
            return count;
        }

        public static bool IsSumPossible(int[] input, int sum)
        {
            HashSet<int> complimentSet = new HashSet<int>();
            foreach(var num in input)
            {
                int compliment = sum - num;
                if (complimentSet.Contains(num))
                    return true;
                complimentSet.Add(compliment);
            }
            return false;
        }

        public static int[] IsSumPossibleRetIndices(int[] nums, int target)
        {
            Dictionary<int, int> complimentSet = new Dictionary<int, int>();
            int[] retArray = new int[2];

            if (nums.Length == 0)
                return retArray;

            for(int i = 0; i<nums.Length; i++)
            {
                int compliment = target - nums[i];
                if (complimentSet.ContainsKey(nums[i]) && complimentSet[nums[i]] != i)
                {
                    retArray[0] = complimentSet[nums[i]];
                    retArray[1] = i;
                    return retArray;
                }
                complimentSet.Add(compliment, i);

            }
            
            return retArray;
        }

        public static int[] FindProduct(int[] nums)
        {
            int n = nums.Length;
            int[] res = new int[n];
            res[0] = 1;
            for (int i = 1; i < n; i++)
            {
                res[i] = res[i - 1] * nums[i - 1];
            }
            int right = 1;
            for (int i = n - 1; i >= 0; i--)
            {
                res[i] *= right;
                right *= nums[i];
            }
            return res;
        }

        public static ListNode AddTwoNumbers(ListNode l1, ListNode l2)
        {
            var r = new ListNode(-1);
            var n = r;
            int carry = 0;
            while (carry > 0 || l1 != null || l2 != null)
            {
                var v = (l1?.val ?? 0) + (l2?.val ?? 0) + carry;
                carry = (int)(v / 10);
                n = n.next = new ListNode(v % 10);
                l1 = l1?.next;
                l2 = l2?.next;
            }
            return r.next;
        }

        public static int LengthOfLongestSubstring(string s)
        {
            s = "abcabcbb";
            HashSet<char> set = new HashSet<char>();
            int maxcount = 0;
            for(int i = 0; i< s.Length; i++)
            {
                set.Add(s[i]);
                var j = i+1;
                while (j < s.Length)
                {
                    if (set.Contains(s[j])) break;
                    else set.Add(s[j]);
                    j++;
                }
                maxcount = Math.Max(maxcount, set.Count);
                set.Clear();
            }
            return maxcount;
        }
        public static string LongestPalindrome(string s)
        {

            if (string.IsNullOrEmpty(s))
            {
                return string.Empty;
            }
            int start = 0, end = 0;
            string result = string.Empty;


            while (end < s.Length)
            {
                if (IsPalindrome(s, start, end))
                {
                    result = (result.Length < (end - start + 1)) ? s.Substring(start, end - start + 1) : result;
                    if (start > 0)
                        start--;
                    end++;
                }
                else
                {
                    start++;
                }
            }
            return result;
        }

        private static bool IsPalindrome(string s, int start, int end)
        {
            while (start < end)
            {
                if (s[start] != s[end])
                {
                    return false;
                }
                start++;
                end--;
            }
            return !(start < end);
        }

        public static List<int> ListOfPrimes(int number)
        {
            var retList = new List<int>();
            if (number < 0 || number == 1)
                return retList;
            for(var i = 2; i<=number; i++)
            {
                IsPrime(i, retList);
            }

            return retList;
        }

        public static void IsPrime(int number, List<int> list)
        {
            var num = Math.Sqrt(number);
            for(var i=2; i<num; i++)
            {

            }
        }
    }
    public class ListNode<T>
    {
        public T value { get; set; }
        public ListNode<T> next { get; set; }

        
    }

    public class ListNode
    {
        public int val;
        public ListNode next;
        public ListNode(int x) { val = x; }
    }

    public class TreeNode
    {
        public int val;
        public TreeNode left;
        public TreeNode right;
        public TreeNode(int x) { val = x; }
    }
}
